# podborka
#go
## Строки
Строки в Go объявляются с типом `string` или сокращенно:

```
var s string = "hello"
```

Практически всегда для строк используются двойные кавычки. Однако они не подходят, когда нужно написать несколько строк. Для этого используются обратные кавычки:

```
q := `
    SELECT *
    FROM person
    WHERE age > 18
`
```

Строки можно сравнивать операторами: `==`, `>`, `<`, `<=`, `>=`, где строки сравниваются посимвольно в лексическом порядке и по длине. Это свойство часто используется при сортировке массива строк:

```
"привет" == "привет" // true
"golang" > "go" // true
"golang" > "lang" // false
"go" > "foobar" // true
```

Базовые операции со строками в любом языке — это конкатенация и интерполяция. Конкатенация осуществляется с помощью знака `+`:

```
"hello " + "world" // "hello world"
```

## Интерполяция
В Go нет привычной интерполяции, как в динамических языках. Она реализуется через форматирующую функцию `fmt.Sprintf()`:

```
username := "Ivan"

greetings := fmt.Sprintf("hello, %s", username) // "hello, Ivan"
```
% - после этого символа указывается глагол формата:
#### Стандартные форматы и тип

Значение: []int64{0, 1}

|Формат|Глагол|Описание|
|---|---|---|
|[0 1]|%v|Формат по умолчанию|
|[]int64{0, 1}|%#v|Формат синтаксиса Go|
|[]int64|%T|Тип значения|

#### Целое число (отступ, основание, знак)

Значение: 15

|Формат|Глагол|Описание|
|---|---|---|
|15|%d|Основание 10|
|+15|%+d|Всегда показывать знак|
|␣␣15|%4d|Отступ с пробелами (ширина 4, выравнивание по правому краю)|
|15␣␣|%-4d|Отступ с пробелами (ширина 4, выравнивание по левому краю)|
|0015|%04d|Отступ с нулями (ширина 4)|
|1111|%b|Основание 2|
|17|%o|Основание 8|
|f|%x|Основание 16, нижний регистр|
|F|%X|Основание 16, верхний регистр|
|0xf|%#x|Основание 16, с ведущим 0x|

#### Символ (цитата, Unicode)

Значение: 65 (Unicode буква A)

|Формат|Глагол|Описание|
|---|---|---|
|A|%c|Символ|
|'A'|%q|Цитируемый символ|
|U+0041|%U|Unicode|
|U+0041 'A'|%#U|Unicode с символом|

#### Логическое (true/false)

Используйте %t, чтобы отформатировать логическое значение как true или false.

#### Указатель (шестнадцатеричный)

Используйте %p для форматирования указателя с основанием 16 с начальным 0x.

#### Float (отступ, точность, научная запись)

Значение: 123.456

|Формат|Глагол|Описание|
|---|---|---|
|1.234560e+02|%e|Научная запись|
|123.456000|%f|Десятичная точка, без экспоненты|
|123.46|%.2f|Ширина по умолчанию, точность 2|
|␣␣123.46|%8.2f|Ширина 8, точность 2|
|123.456|%g|Экспонент по мере необходимости, только необходимые цифры|

#### Срез строк или байтов (кавычка, отступ, шестнадцатеричный)

Значение: "café"

|Формат|Глагол|Описание|
|---|---|---|
|café|%s|Обычная строка|
|␣␣café|%6s|Ширина 6, выравнивание по правому краю|
|café␣␣|%-6s|Ширина 6, выравнивание по левому краю|
|"café"|%q|Цитируемая строка|
|636166c3a9|%x|шестнадцатеричный дамп байтовых значений|
|63 61 66 c3 a9|% x|шестнадцатеричный дамп с пробелами|

#### Специальные значения

|Значение|Описание|
|---|---|
|\a|U+0007 оповещение или звонок|
|\b|U+0008 backspace|
|\\|U+005c обратный слэш|
|\t|U+0009 горизонтальный таб|
|\n|U+000A перевод строки (line feed) или новая строка (newline)|
|\f|U+000C form feed|
|\r|U+000D возврат каретки|
|\v|U+000b вертикальный таб|

Произвольные значения могут быть закодированы с помощью обратной косой черты и могут использоваться в любом "" строковом литерале.

Существует четыре разных формата:

- \x, за которыми следуют ровно две шестнадцатеричные цифры
- \ за которыми следуют ровно три восьмеричные цифры
- \u за которыми следуют ровно четыре шестнадцатеричные цифры
- \U за которыми следуют ровно восемь шестнадцатеричных цифр

Экранирование \u и \U представляет кодовые точки Unicode.

```
fmt.Println("\\caf\u00e9") // Печатает \café
```
#### Другое пояснение
Каждый спецификатор представляет определенный тип данных:

- `%t`: для вывода значений типа boolean (true или false)
    
- `%b`: для вывода целых чисел в двоичной системе
    
- `%c`: для вывода символов, представленных числовым кодом
    
- `%d`: для вывода целых чисел в десятичной системе
    
- `%o`: для вывода целых чисел в восьмеричной системе
    
- `%q`: для вывода символов в одинарных кавычках
    
- `%x`: для вывода целых чисел в шестнадцатеричной системе, буквенные символы числа имеют нижний регистр a-f
    
- `%X`: для вывода целых чисел в шестнадцатеричной системе, буквенные символы числа имеют верхний регистр A-F
    
- `%U`: для вывода символов в формате кодов Unicode, например, U+1234
    
- `%e`: для вывода чисел с плавающей точкой в экспоненциальном представлении, например, -1.234456e+78
    
- `%E`: тоже самое что `%e` но в верхнем регистре, например, -1.234456E+78
    
- `%f`: для вывода чисел с плавающей точкой, например, 123.456
    
- `%F`: то же самое, что и %f
    
- `%g`   %e для огромных экспонент, %f в противном случае
    
- `%G`    %E для огромных экспонент, %F в противном случае
    
- `%s`: для вывода строки
    
- `%p`: для вывода значения указателя - адреса в шестнадцатеричном представлении (указатели мы пройдем на следующих уроках)
    
- `%T` для вывода типа переменной
    

Также можно применять универсальный спецификатор `%v`, который для типа boolean аналогичен `%t`, для целочисленных типов - `%d`, для чисел с плавающей точкой - `%g`, для строк - `%s`.

К спецификаторам можно добавлять различные флаги, которые влияют на форматирование значений. Например, число перед спецификатором указывает, какую минимальную длину в символах будет занимать выводимое значение. Например, `%9f` - число с плавающей точкой будет занимать как минимум 9 позиций. Если ширина больше, чем требуется значению, то заполняется пробелами.

Для чисел с плавающей точкой можно указать точность или количество символов в дробной части. Для этого количество символов указывается после точки: `%.2f` - две цифры в дробной части после точки. Например, варианты форматирования чисел с плавающей точкой:

- `%f`: точность и ширина значения по умолчанию
    
- `%9f`: ширина - 9 символов и точность по умолчанию  
    (число с плавающей точкой будет занимать как минимум 9 позиций. Если ширина больше, чем требуется значению, то заполняется пробелами.)
    
- `%.2f`: ширина по умолчанию и точность - 2 символа
    
- `%9.2f`: ширина - 9 и точность - 2
    
- `%9.f`: ширина - 9 и точность - 0

## Длина строк
Узнать длину строки можно с помощью встроенной функции `len()`:

```
len("go") // 2

// будьте внимательны! Функция считает кол-во байт, а не кол-во символов
len("го") // 4
```
## Библиотека strings
Go содержит большое количество функций для работы со строками в пакете `strings` , кратко рассмотрим основные: 


```go
package main

import (
    "fmt"
    "strings"
)

func main() {
    fmt.Println(    
        // Содержится ли подстрока в строке    
        strings.Contains("test", "es"), 
        // результат: true

        // Кол-во подстрок в строке
        strings.Count("test", "t"),
        // результат: 2

        // Начинается ли строка с префикса       
        strings.HasPrefix("test", "te"), 
        // результат: true

        // Заканчивается ли строка суффиксом
        strings.HasSuffix("test", "st"), 
        // результат: true

        // Возвращает начальный индекс подстроки в строке, а при отсутствии вхождения возвращает -1
        strings.Index("test", "e"), 
        // результат: 1

        // объединяет массив строк через символ
        strings.Join([]string{"hello","world"}, "-"),
        // результат: "hello-world"

        // Повторяет строку n раз подряд
        strings.Repeat("a", 5), 
        // результат: "aaaaa"

        // Функция Replace заменяет любое вхождение old в вашей строке на new
        // Если значение n равно -1, то будут заменены все вхождения.
        // Общий вид: func Replace(s, old, new string, n int) string
        // Пример:
        strings.Replace("blanotblanot", "not", "***", 	-1),
        // результат: "bla***bla***"
 
        // Разбивает строку согласно разделителю
        strings.Split("a-b-c-d-e", "-"), 
        // результат: []string{"a","b","c","d","e"}

        // Возвращает строку c нижним регистром
        strings.ToLower("TEST"), 
        // результат: "test"

        // Возвращает строку c верхним регистром
        strings.ToUpper("test"), 
        // результат: "TEST"

        // Возвращает строку с вырезанным набором
        strings.Trim("tetstet", "te"),
        // результат: s
    )
}
```

Так как мы рассмотрели только основные функции мы рекомендуем ознакомиться с официальной документацией пакета "strings" - [https://godoc.org/strings](https://godoc.org/strings) .
## Библиотека Unicode
Помимо пакета strings, есть некоторые полезные функции из пакета unicode для работы с символами.  
 

```go
package main

import (
	"fmt"
	"unicode"
)

func main() {
    // функции ниже принимают на вход тип rune


    // проверка символа на цифру
	fmt.Println(unicode.IsDigit('1')) // true
    // проверка символа на букву
	fmt.Println(unicode.IsLetter('a')) // true 
    // проверка символа на нижний регистр
	fmt.Println(unicode.IsLower('A')) // false
    // проверка символа на верхний регистр
	fmt.Println(unicode.IsUpper('A')) // true
    // проверка символа на пробел 
    // пробел это не только ' ', но и:
    //  '\t', '\n', '\v', '\f', '\r' - подробнее читайте в документации
	fmt.Println(unicode.IsSpace('\t')) // true 

    // С помощью функции Is можно проверять на кастомный RangeTable:
    // например, проверка на латиницу:
 	fmt.Println(unicode.Is(unicode.Latin, 'ы')) // false


    // функции преобразований
	fmt.Println(string(unicode.ToLower('F'))) // f
	fmt.Println(string(unicode.ToUpper('f'))) // F
}
```

Если хотите ознакомиться подробнее с этим пакетом - советуем почитать [документацию](https://golang.org/pkg/unicode/).
